// tests/integration/sessions.integration.test.ts
import { sessions } from "../../db/Session";
import { query } from "../../db/connect";
import { randomUUID } from "crypto";

describe("sessions repository (integration)", () => {
  let userId: string;

  // Create a fresh user for each test so FK checks pass
  beforeEach(async () => {
    const { rows } = await query<{ id: string }>(
      `
      INSERT INTO users (email, username, password_hash, role)
      VALUES ($1, $2, $3, $4)
      RETURNING id
      `,
      [
        `itest_${Date.now()}@example.com`,
        `itest_${Math.random().toString(36).slice(2)}`,
        "hashedpw",
        "Volunteer",
      ]
    );
    userId = rows[0].id; // UUID generated by DB (gen_random_uuid())
  });

  // Clear tables between tests (order matters if no CASCADE)
  
  afterEach(async () => {
    await query("DELETE FROM refresh_tokens");
   // await query("DELETE FROM users");
  });
  

  test("create() inserts a refresh token record", async () => {
    const rec = {
      jti: randomUUID(), // ← valid UUID
      userId,
      expiresAt: new Date("2030-01-01T00:00:00Z"),
    };

    await sessions.create(rec);

    const { rows } = await query(
      "SELECT * FROM refresh_tokens WHERE jti = $1",
      [rec.jti]
    );
    expect(rows).toHaveLength(1);
    expect(rows[0].user_id).toBe(userId);
  });

  test("findByJti() returns matching session", async () => {
    const jti = randomUUID();

    await query(
      `
      INSERT INTO refresh_tokens (jti, user_id, expires_at)
      VALUES ($1, $2, $3)
      `,
      [jti, userId, "2030-01-01T00:00:00Z"]
    );

    const found = await sessions.findByJti(jti);
    expect(found).not.toBeNull();
    expect(found?.user_id).toBe(userId);
  });

  test("findByJti() returns null for missing session", async () => {
    const missing = await sessions.findByJti(randomUUID()); // guaranteed not present
    expect(missing).toBeNull();
  });

  test("revoke() sets revoked_at for one token", async () => {
    const revokeJti = randomUUID();

    await query(
      `
      INSERT INTO refresh_tokens (jti, user_id, expires_at)
      VALUES ($1, $2, $3)
      `,
      [revokeJti, userId, "2030-01-01T00:00:00Z"]
    );

    await sessions.revoke(revokeJti);

    const { rows } = await query(
      "SELECT revoked_at FROM refresh_tokens WHERE jti = $1",
      [revokeJti]
    );
    expect(rows[0]).not.toBeNull();
  });

  test("revokeAllForUser() revokes all active tokens for a user", async () => {
    const jtiA = randomUUID();
    const jtiB = randomUUID();

    await query(
      `
      INSERT INTO refresh_tokens (jti, user_id, expires_at)
      VALUES ($1, $2, $3), ($4, $2, $3)
      `,
      [jtiA, userId, "2030-01-01T00:00:00Z", jtiB]
    );

    await sessions.revokeAllForUser(userId);

    const { rows } = await query(
      "SELECT revoked_at FROM refresh_tokens WHERE user_id = $1",
      [userId]
    );
    expect(rows.every(r => r.revoked_at !== null)).toBe(true);
  });
});